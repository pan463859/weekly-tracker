(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{703:function(e,t,v){"use strict";v.r(t);var _=v(11),r=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("在我们日常开发中，很少会去调试内存泄漏的问题，虽然是有工具可以实现调试的，但是它调试起来很复杂繁琐，通常也不会准确地告诉我们:我们的系统为什么会出现内存泄漏。")]),e._v(" "),v("p",[e._v("在我的印象中，JavaScript 是一个自带垃圾回收机制的语言，应该很少会出现内存泄漏的问题。但是当我第一次开始研究内存泄漏时，却发现它却成为了内存泄漏的主要来源。随着研究的深入，我发现在单页面应用程序(Single Page Apps，简称 spa)上是普遍存在内存泄漏问题的，只是很少有人对这些应用做测试。")]),e._v(" "),v("p",[e._v("很少有 web 开发人员会注意到内存泄漏的问题，通常是因为他们发现自己的网站正在变慢，变卡甚至崩溃，或者偶然间在内存工具中发现页面占用了 N 兆(甚至 N 千兆)的内存时，才会考虑系统是否存在内存泄漏。不过当他们注意到这些问题的时候，系统出现内存泄露的点可能就不止一个了。")]),e._v(" "),v("p",[e._v("回顾我之前写过的"),v("a",{attrs:{href:"https://nolanlawson.com/2020/02/19/fixing-memory-leaks-in-web-applications/",target:"_blank",rel:"noopener noreferrer"}},[e._v("关于内存泄露的文章"),v("OutboundLink")],1),e._v("就会发现，我通常都会建议开发中通过 Chrome 的内存监测工具来进行调试，但是由于工具的复杂程度，大部分人都很难通过它来查找除内存泄漏的原因。所以我希望有一个 CLI 工具来实现这些复杂的操作。")]),e._v(" "),v("p",[e._v("因此我写了一个工具"),v("code",[e._v("fuite (法语“ leak”)")]),e._v("。在这个 CLI 工具中，我们可以用通过它来分析任意的一个网址是否存在内存泄漏的问题。")]),e._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("npx fuite https://example.com\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[e._v("在执行命令时，"),v("code",[e._v("fuite")]),e._v("会默认网站是呈现给用户的一个 SPA 页面，之后会抓取页面中的内部链接(例如"),v("code",[e._v("/about")]),e._v("或"),v("code",[e._v("/contact")]),e._v(")。获取到链接后，会按照下面步骤来执行：")]),e._v(" "),v("ol",[v("li",[e._v("点击链接")]),e._v(" "),v("li",[e._v("点击浏览器的返回按钮")]),e._v(" "),v("li",[e._v("重复操作来监测内存是否增长\n当"),v("code",[e._v("fuite")]),e._v("监测到内存异常时，会告知我们哪些对象可能会导致内存泄漏。")])]),e._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("Test         : Go to /foo and back\nMemory change: +10 MB\nLeak detected: Yes\nLeaking objects:\n| Object            | # added | Retained size increase |\n| ----------------- | ------- | ---------------------- |\n| HTMLIFrameElement | 1       | +10 MB                 |\nLeaking event listeners:\n| Event        | # added | Nodes  |\n| ------------ | ------- | ------ |\n| beforeunload | 2       | Window |\nLeaking DOM nodes:\nDOM size grew by 6 node(s) \n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br"),v("span",{staticClass:"line-number"},[e._v("6")]),v("br"),v("span",{staticClass:"line-number"},[e._v("7")]),v("br"),v("span",{staticClass:"line-number"},[e._v("8")]),v("br"),v("span",{staticClass:"line-number"},[e._v("9")]),v("br"),v("span",{staticClass:"line-number"},[e._v("10")]),v("br"),v("span",{staticClass:"line-number"},[e._v("11")]),v("br"),v("span",{staticClass:"line-number"},[e._v("12")]),v("br"),v("span",{staticClass:"line-number"},[e._v("13")]),v("br")])]),v("p",[e._v("为了实现这个功能，我在"),v("code",[e._v("fuite")]),e._v("中使用了博客文章中阐述的基本策略。他会启动 Chrome 来运行 n 次(默认 7 次),并检查是否有对象发生内存泄漏了 n 次(7,14,21 等）。")]),e._v(" "),v("p",[v("code",[e._v("fuite")]),e._v("同时会分析全部的 "),v("code",[e._v("Array")]),e._v(", "),v("code",[e._v("Object")]),e._v(","),v("code",[e._v("Map")]),e._v(", "),v("code",[e._v("Set")]),e._v("，事件监听器以及整个 DOM。假如一个数组在执行了 7 次后同时也增长了 7 次，那么这个对象就有可能发生了内存泄漏。")]),e._v(" "),v("h3",{attrs:{id:"测试正式网站"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#测试正式网站"}},[e._v("#")]),e._v(" 测试正式网站")]),e._v(" "),v("p",[e._v("但是令人惊讶的是，仅仅通过点击内部链接并点击浏览器的返回按钮的基本场景就足以发现 SPA 中的内存泄漏。下面是我对 10 个前端主流框架的首页进行的测试结果,并发现他们都存在内存泄漏的问题。")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[e._v("站点")]),e._v(" "),v("th",[e._v("是否发生泄漏")]),e._v(" "),v("th",[e._v("内部连接数")]),e._v(" "),v("th",[e._v("平均增长")]),e._v(" "),v("th",[e._v("最大增长数")])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("Site 1")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("8")]),e._v(" "),v("td",[e._v("27.2 kB")]),e._v(" "),v("td",[e._v("43 kB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 2")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("10")]),e._v(" "),v("td",[e._v("50.4 kB")]),e._v(" "),v("td",[e._v("78.9 kB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 3")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("27")]),e._v(" "),v("td",[e._v("98.8 kB")]),e._v(" "),v("td",[e._v("135 kB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 4")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("8")]),e._v(" "),v("td",[e._v("180 kB")]),e._v(" "),v("td",[e._v("212 kB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 5")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("13")]),e._v(" "),v("td",[e._v("266 kB")]),e._v(" "),v("td",[e._v("1.07 MB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 6")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("8")]),e._v(" "),v("td",[e._v("638 kB")]),e._v(" "),v("td",[e._v("1.15 MB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 7")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("7")]),e._v(" "),v("td",[e._v("1.37 MB")]),e._v(" "),v("td",[e._v("2.25 MB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 8")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("15")]),e._v(" "),v("td",[e._v("3.49 MB")]),e._v(" "),v("td",[e._v("4.28 MB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 9")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("43")]),e._v(" "),v("td",[e._v("5.57 MB")]),e._v(" "),v("td",[e._v("7.37 MB")])]),e._v(" "),v("tr",[v("td",[e._v("Site 10")]),e._v(" "),v("td",[e._v("yes")]),e._v(" "),v("td",[e._v("16")]),e._v(" "),v("td",[e._v("14.9 MB")]),e._v(" "),v("td",[e._v("186 MB")])])])]),e._v(" "),v("p",[e._v("在这种情况下，"),v("code",[e._v("内部链接")]),e._v("是指所测试的内部链接数目，"),v("code",[e._v("平均增长")]),e._v("是指每个链接的平均内存增长(即每次跳转页面并返回) ，而"),v("code",[e._v("最大增长")]),e._v("是指内部链接内存泄漏的最大值。值得注意的时，这些数据并不是一次的测试结果而是"),v("code",[e._v("fuite")]),e._v("测试了 7 次之后的结果。")]),e._v(" "),v("p",[e._v("当我们要确定这些结果的真实性时,你可以使用 Chrome DevTools 的"),v("code",[e._v("Memory")]),e._v("工具。下面图片是我选择了测试中性能最差的站点，点击其中的一个链接，然后按下后退键。每次操作都保存一个堆得快照，然后重复操作。")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34e6836feb8d47018b63611dd73ae2ff~tplv-k3u1fbpfcp-watermark.image?",alt:"74a805399e214e6a054c93ad6e9d4ba.jpg"}})]),e._v(" "),v("p",[e._v("我们可以发现每次点击连接并返回时，内存都会增加约 6MB。")]),e._v(" "),v("h3",{attrs:{id:"注意事项"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[e._v("#")]),e._v(" 注意事项")]),e._v(" "),v("p",[e._v("我们要注意的是并不是所有的 SPA 中的内存泄漏都是需要解决的。比如，当 SPA 需要维护焦点和滚动状态以正确支持可访问性，这意味着可能会为每个页面导航存储一些小的元数据。"),v("code",[e._v("fuite")]),e._v("将会报告此类泄漏，但是需要由开发人员决定是否值得追踪这微小的泄漏。")]),e._v(" "),v("p",[e._v("在开发过程中，一些内存的增长可能是由于浏览器内部的原因造成的(比如 JITing)，这是网页无法真正控制的。正因如此，内存增长并不意味着你的代码存在问题，很多情况下内存的增长是不可避免的。")]),e._v(" "),v("p",[e._v("在少数情况下，由于浏览器的一些 bug 也会造成内存的增长。在分析上面网站时，由于 Chrome 的 bug 导致站点#4 出现了问题。由于"),v("code",[e._v("fuite")]),e._v("是程序，所以很难检测到是否是浏览器的问题。在"),v("code",[e._v("fuite")]),e._v("有警告的情况下，我们可以对比下其他浏览器，来确定问题究竟来源于何处。")]),e._v(" "),v("p",[e._v("说完了 SPA 的应用，在我们传统的 MPA(多页面应用程序)中，几乎不可能出现泄漏问题，因为每次当我们切换页面时，浏览器都会清除内存。当然，这都是在浏览器没有 bug 的前提下。")]),e._v(" "),v("p",[v("code",[e._v("fuite")]),e._v("目前只测量页面主框架中的 JavaScript 堆内存，因此不测量跨域 iframe、Web Workers 和 Service Workers。")]),e._v(" "),v("h3",{attrs:{id:"其他内存泄漏的场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他内存泄漏的场景"}},[e._v("#")]),e._v(" 其他内存泄漏的场景")]),e._v(" "),v("p",[v("code",[e._v("fuite")]),e._v("通过获取页面内部链接来进行测试只是一个默认的方案。"),v("code",[e._v("fuite")]),e._v("是构建在 Puppeteer 之上的，因此你可以通过编写自己的 Puppeteer 脚本来告知 fuite 如何去测试你想要测试的内容。这里提供一些可能需要测试的场景：")]),e._v(" "),v("ol",[v("li",[e._v("反复打开/关闭一个模态框")]),e._v(" "),v("li",[e._v("鼠标悬停在某一个元素上时，显示一些提示。当鼠标移出时，删除对应的 DOM。")]),e._v(" "),v("li",[e._v("滚动浏览无限加载列表，然后导航离开和返回")])]),e._v(" "),v("p",[e._v("在这些场景中，可能会存在你意想不到的内存泄露的问题。当测试了许多应用后，就会发现很多对话框或者工具提示都存储着内存泄漏的问题。")]),e._v(" "),v("p",[e._v("在底层，fuite 它是一个相当基本的工具，我不会声称它可以 100% 地完成修复内存泄漏的工作。仍然需要人为因素来弄清楚内存泄漏的具体原因，然后找到一个合理的解决方案。但是我的目标是自动化约 95% 的工作，这样实际上修复 Web 应用程序中的内存泄漏是可以实现的。")]),e._v(" "),v("h3",{attrs:{id:"相关链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相关链接"}},[e._v("#")]),e._v(" 相关链接")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://nolanlawson.com/2021/12/17/introducing-fuite-a-tool-for-finding-memory-leaks-in-web-apps/",target:"_blank",rel:"noopener noreferrer"}},[e._v("⛱ 原文地址"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"https://github.com/nolanlawson/fuite",target:"_blank",rel:"noopener noreferrer"}},[e._v("⛱ fuite GitHub"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"https://youtu.be/H0BHL2lo89M",target:"_blank",rel:"noopener noreferrer"}},[e._v("⛱ 作者视频"),v("OutboundLink")],1)]),e._v(" "),v("hr"),e._v(" "),v("blockquote",[v("ul",[v("li",[e._v("译文出自："),v("a",{attrs:{href:"https://github.com/FEDarling/weekly-tracker",target:"_blank",rel:"noopener noreferrer"}},[e._v("weekly-tracker"),v("OutboundLink")],1),e._v(" 项目，期待你的加入！")]),e._v(" "),v("li",[v("a",{attrs:{href:"https://nolanlawson.com/2021/12/17/introducing-fuite-a-tool-for-finding-memory-leaks-in-web-apps/",target:"_blank",rel:"noopener noreferrer"}},[e._v("查看原文"),v("OutboundLink")],1),e._v("对比阅读")]),e._v(" "),v("li",[e._v("发现错误？"),v("a",{attrs:{href:"https://github.com/FEDarling/weekly-tracker/blob/main/weeklys/javascript_weekly/571/fuite.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("提交 PR"),v("OutboundLink")],1)]),e._v(" "),v("li",[e._v("译者："),v("a",{attrs:{href:"https://github.com/chressYu",target:"_blank",rel:"noopener noreferrer"}},[e._v("HongyuYU"),v("OutboundLink")],1)]),e._v(" "),v("li",[e._v("校对者："),v("a",{attrs:{href:"https://github.com/LilyChenlin",target:"_blank",rel:"noopener noreferrer"}},[e._v("LilyChenlin"),v("OutboundLink")],1)])])])])}),[],!1,null,null,null);t.default=r.exports}}]);